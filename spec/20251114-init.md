## Spec Completa - Fluxo

### 1. Estrutura de Diretórios

```
fluxo/
├── cmd/
│   └── fluxo/
│       └── main.go
├── internal/
│   ├── config/
│   │   ├── config.go
│   │   ├── loader.go
│   │   └── flags.go
│   ├── server/
│   │   ├── server.go
│   │   ├── listener.go
│   │   └── shutdown.go
│   ├── graphql/
│   │   ├── schema.go
│   │   ├── resolver.go
│   │   ├── torrent_resolver.go
│   │   ├── mutation_resolver.go
│   │   ├── query_resolver.go
│   │   ├── subscription_resolver.go
│   │   └── types.go
│   └── session/
│       ├── manager.go
│       ├── events.go
│       └── watcher.go
├── web/
│   ├── package.json
│   ├── relay.config.js
│   ├── vite.config.js
│   ├── tailwind.config.js
│   ├── src/
│   │   ├── main.tsx
│   │   ├── App.tsx
│   │   ├── components/
│   │   │   ├── TorrentList.tsx
│   │   │   ├── TorrentCard.tsx
│   │   │   ├── AddTorrentModal.tsx
│   │   │   └── StatsBar.tsx
│   │   ├── __generated__/
│   │   └── relay/
│   │       └── environment.ts
│   └── public/
├── go.mod
├── go.sum
└── README.md
```

### 2. Fluxo de Inicialização

1. Cobra parseia flags/args
2. Viper carrega config (flags → env → file → defaults)
3. Viper unmarshals para struct Config
4. Server.New() recebe config
5. Server inicializa session.Manager (wraps torrent.Session)
6. Server inicializa GraphQL resolver
7. Server inicializa HTTP listener
8. Server inicia watcher goroutine
9. Graceful shutdown no SIGINT/SIGTERM

### 3. Session Manager

**Responsabilidades**:
- Wrapper sobre torrent.Session do Rain
- Métodos para GraphQL (AddTorrent, GetTorrents, etc)
- Event bus interno (channel-based)
- Eventos: TorrentAdded, TorrentRemoved, TorrentUpdated, StatsUpdated

**Event Bus**:
- Múltiplos subscribers via channels
- Watcher faz polling periódico
- GraphQL subscriptions consomem eventos

### 4. GraphQL Layer

**Biblioteca**: https://github.com/99designs/gqlgen

**Resolver Pattern**:
- Root resolver com referência ao session.Manager
- Queries/mutations chamam métodos do manager
- Subscriptions usam event bus
- Erros do Rain mapeados para GraphQL errors

**Subscription**:
- WebSocket via graphql-ws protocol
- Cada subscription abre channel no event bus
- Cleanup automático no disconnect

### 5. HTTP Listener

**Router**: net/http

**Endpoints**:
- POST /graphql - queries/mutations
- GET /graphql - WebSocket para subscriptions
- GET /graphiql - GraphiQL interface
- GET /* - React app (embed.FS)

**Middleware**:
- CORS
- Request logging
- Panic recovery
- Request timeout

**WebSocket**:
- gorilla/websocket
- graphql-ws protocol
- Heartbeat 30s

### 6. Configuração (Cobra + Viper)

**Precedência**: flags → env vars → config file → defaults

**Struct**:
- Config do Fluxo (APIPort, APIHost, WatchInterval)
- torrent.Config embedded (todas as configs do Rain)

**Viper**:
- SetEnvPrefix("FLUXO")
- AutomaticEnv()
- EnvKeyReplacer("-", "_")
- BindPFlags() para todas as flags
- ReadInConfig() com fallback silencioso

**Flags**:
- Todas as configs expostas como flags
- Geração automática via reflection sobre torrent.Config
- Nome em dash-case (port-begin, data-dir, etc)

**Config Paths** (ordem):
1. --config flag
2. ./fluxo.yaml
3. ~/.fluxo/config.yaml
4. /etc/fluxo/config.yaml

**Mapeamento**:
- Struct: APIPort
- YAML: api-port
- Flag: --api-port
- Env: FLUXO_API_PORT

**Defaults do Fluxo**:
- APIPort: 8080
- APIHost: 127.0.0.1
- WatchInterval: 1s
- Rain configs: defaults do Rain com paths modificados:
  - Database: ~/.fluxo/session.db
  - DataDir: ~/.fluxo/downloads
  - RPCEnabled: false

### 7. Build & Embed

**Frontend**:
- npm run build → web/dist/
- Go embed.FS embute web/dist no binário
- Produção serve do embed
- Dev mode opcional (proxy para Vite)

**Binary**:
- go build -o fluxo
- Frontend embedded
- Cross-compile Linux/macOS/Windows

### 8. Watcher Goroutine

**Funcionamento**:
- Loop com ticker (configurável via --watch-interval)
- Lista torrents e compara com cache
- Detecta mudanças (status, bytes, speed)
- Emite eventos no event bus
- Context cancellation para shutdown

**Otimizações**:
- Só emite se mudou
- Rate limiting para muitos torrents
- Comparação eficiente de structs

### 9. Event Bus

**Implementação**:
- Map de channels (subscriber ID → channel)
- Subscribe() retorna channel de eventos
- Unsubscribe() fecha channel
- Publish() envia para todos subscribers (non-blocking)
- Buffered channels (100 items)

**Eventos**:
- TorrentAdded
- TorrentRemoved
- TorrentUpdated
- StatsUpdated

### 10. Listener Extensível

**Interface**:
- Name() string
- Start(ctx, manager, schema) error
- Stop(ctx) error

**HTTP Listener**: implementação default

**Futuros**: gRPC, TCP, Unix Socket

### 11. Graceful Shutdown

**Sequência**:
1. Para listeners (não aceita conexões)
2. Para watcher goroutine
3. Fecha event bus
4. Fecha Rain session (salva estado)
5. Timeout 10s

### 12. Logging

- Logger do Rain (internal/logger)
- Structured logging (key-value)
- Níveis: Debug, Info, Notice, Warning, Error
- Flag --debug ativa Debug level

### 13. Error Handling

**Tipos**:
- Input errors (user error, 400)
- Not found (404)
- Internal (500)

**Mapeamento**:
- torrent.InputError → Input error
- torrent.AnnounceError → Internal error
- Default → Internal error

**Validações**:
- Torrent ID (40 hex chars)
- URI (magnet, HTTP, ou base64)
- Sanitização de inputs

**Subscriptions**:
- Erros fecham channel
- Client reconecta

### 14. WebUI

**Stack**:
- React
- Relay (GraphQL client)
- DaisyUI 5
- Tailwind 4
- Vite
- TypeScript

**DaisyUI**:
- Temas: light, dark
- Componentes: cards, modals, stats, badges e o que mais for necessário, prefira tabelas a cards para lista de arquivos e torrents

**Relay**:
- GraphQL queries/mutations via HTTP
- Subscriptions via WebSocket
- Codegen automático

**Componentes**:
- TorrentList (subscription para torrents)
- TorrentCard (display de torrent individual)
- AddTorrentModal (mutation addTorrent)
- StatsBar (subscription para stats)

**Rotas**:
- / - Interface principal
- /graphiql - GraphiQL playground

---

## GraphQL Schema

```graphql
scalar Time

enum TorrentStatus {
  STOPPED
  DOWNLOADING_METADATA
  ALLOCATING
  VERIFYING
  DOWNLOADING
  SEEDING
  STOPPING
}

enum TrackerStatus {
  IDLE
  ANNOUNCING
  WAITING
  ERROR
}

enum PeerSource {
  TRACKER
  DHT
  PEX
  INCOMING
}

type Torrent {
  id: ID!
  name: String!
  infoHash: String!
  addedAt: Time!
  status: TorrentStatus!
  
  # Bytes (String para suportar >2^53)
  bytesCompleted: String!
  bytesTotal: String!
  bytesDownloaded: String!
  bytesUploaded: String!
  bytesMissing: String!
  
  # Speed (bytes/sec)
  downloadSpeed: Int!
  uploadSpeed: Int!
  
  # Time (seconds)
  eta: Int
  seedingTime: Int!
  downloadTime: Int!
  
  # Pieces
  piecesTotal: Int!
  piecesHave: Int!
  piecesAvailable: Int!
  pieceLength: Int!
  
  # Peers
  peers: PeerStats!
  
  # Collections
  files: [File!]!
  trackers: [Tracker!]!
  webseeds: [Webseed!]!
  
  # Metadata
  private: Boolean!
  
  # Error state
  error: String
}

type PeerStats {
  total: Int!
  incoming: Int!
  outgoing: Int!
}

type File {
  path: String!
  length: String!
  bytesCompleted: String!
  priority: Int!
}

type Tracker {
  url: String!
  status: TrackerStatus!
  leechers: Int
  seeders: Int
  error: String
  nextAnnounce: Time
  lastAnnounce: Time
}

type Webseed {
  url: String!
  downloadSpeed: Int!
  bytesDownloaded: String!
  error: String
}

type Peer {
  id: String!
  client: String!
  addr: String!
  source: PeerSource!
  connectedAt: Time!
  
  # State
  downloading: Boolean!
  clientInterested: Boolean!
  clientChoking: Boolean!
  peerInterested: Boolean!
  peerChoking: Boolean!
  optimisticUnchoked: Boolean!
  snubbed: Boolean!
  
  # Encryption
  encryptedHandshake: Boolean!
  encryptedStream: Boolean!
  
  # Speed
  downloadSpeed: Int!
  uploadSpeed: Int!
}

type SessionStats {
  uptime: Int!
  torrents: Int!
  peers: Int!
  portsAvailable: Int!
  blocklistRules: Int!
  blocklistRecency: Int!
  
  # Cache stats
  readCacheObjects: Int!
  readCacheSize: String!
  readCacheUtilization: Int!
  
  # Disk IO
  readsPerSecond: Int!
  readsActive: Int!
  readsPending: Int!
  
  # Write cache
  writeCacheObjects: Int!
  writeCacheSize: String!
  writeCachePendingKeys: Int!
}

input AddTorrentInput {
  uri: String!
  stopped: Boolean
  stopAfterDownload: Boolean
  stopAfterMetadata: Boolean
}

type Query {
  torrents: [Torrent!]!
  torrent(id: ID!): Torrent
  sessionStats: SessionStats!
  torrentPeers(id: ID!): [Peer!]!
}

type Mutation {
  addTorrent(input: AddTorrentInput!): Torrent!
  removeTorrent(id: ID!): Boolean!
  
  startTorrent(id: ID!): Boolean!
  stopTorrent(id: ID!): Boolean!
  startAllTorrents: Boolean!
  stopAllTorrents: Boolean!
  
  verifyTorrent(id: ID!): Boolean!
  announceTorrent(id: ID!): Boolean!
  
  addTracker(id: ID!, url: String!): Boolean!
  addPeer(id: ID!, addr: String!): Boolean!
}

type Subscription {
  torrentAdded: Torrent!
  torrentRemoved: ID!
  torrentUpdated(id: ID): Torrent!
  statsUpdated: SessionStats!
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
```
