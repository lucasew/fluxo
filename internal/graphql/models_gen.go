// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type AddTorrentInput struct {
	URI               *string `json:"uri,omitempty"`
	TorrentData       *string `json:"torrentData,omitempty"`
	Stopped           *bool   `json:"stopped,omitempty"`
	StopAfterDownload *bool   `json:"stopAfterDownload,omitempty"`
	StopAfterMetadata *bool   `json:"stopAfterMetadata,omitempty"`
}

type File struct {
	Path           string `json:"path"`
	Length         string `json:"length"`
	BytesCompleted string `json:"bytesCompleted"`
	Priority       int    `json:"priority"`
}

type Mutation struct {
}

type Peer struct {
	ID                 string     `json:"id"`
	Client             string     `json:"client"`
	Addr               string     `json:"addr"`
	Source             PeerSource `json:"source"`
	ConnectedAt        time.Time  `json:"connectedAt"`
	Downloading        bool       `json:"downloading"`
	ClientInterested   bool       `json:"clientInterested"`
	ClientChoking      bool       `json:"clientChoking"`
	PeerInterested     bool       `json:"peerInterested"`
	PeerChoking        bool       `json:"peerChoking"`
	OptimisticUnchoked bool       `json:"optimisticUnchoked"`
	Snubbed            bool       `json:"snubbed"`
	EncryptedHandshake bool       `json:"encryptedHandshake"`
	EncryptedStream    bool       `json:"encryptedStream"`
	DownloadSpeed      int        `json:"downloadSpeed"`
	UploadSpeed        int        `json:"uploadSpeed"`
}

type PeerStats struct {
	Total    int `json:"total"`
	Incoming int `json:"incoming"`
	Outgoing int `json:"outgoing"`
}

type Query struct {
}

type SessionStats struct {
	Uptime                int    `json:"uptime"`
	Torrents              int    `json:"torrents"`
	Peers                 int    `json:"peers"`
	PortsAvailable        int    `json:"portsAvailable"`
	BlocklistRules        int    `json:"blocklistRules"`
	BlocklistRecency      int    `json:"blocklistRecency"`
	ReadCacheObjects      int    `json:"readCacheObjects"`
	ReadCacheSize         string `json:"readCacheSize"`
	ReadCacheUtilization  int    `json:"readCacheUtilization"`
	ReadsPerSecond        int    `json:"readsPerSecond"`
	ReadsActive           int    `json:"readsActive"`
	ReadsPending          int    `json:"readsPending"`
	WriteCacheObjects     int    `json:"writeCacheObjects"`
	WriteCacheSize        string `json:"writeCacheSize"`
	WriteCachePendingKeys int    `json:"writeCachePendingKeys"`
}

type Subscription struct {
}

type Torrent struct {
	ID              string        `json:"id"`
	Name            string        `json:"name"`
	InfoHash        string        `json:"infoHash"`
	AddedAt         time.Time     `json:"addedAt"`
	Status          TorrentStatus `json:"status"`
	BytesCompleted  string        `json:"bytesCompleted"`
	BytesTotal      string        `json:"bytesTotal"`
	BytesDownloaded string        `json:"bytesDownloaded"`
	BytesUploaded   string        `json:"bytesUploaded"`
	BytesMissing    string        `json:"bytesMissing"`
	DownloadSpeed   int           `json:"downloadSpeed"`
	UploadSpeed     int           `json:"uploadSpeed"`
	Eta             *int          `json:"eta,omitempty"`
	SeedingTime     int           `json:"seedingTime"`
	DownloadTime    int           `json:"downloadTime"`
	PiecesTotal     int           `json:"piecesTotal"`
	PiecesHave      int           `json:"piecesHave"`
	PiecesAvailable int           `json:"piecesAvailable"`
	PieceLength     int           `json:"pieceLength"`
	Peers           *PeerStats    `json:"peers"`
	Files           []*File       `json:"files"`
	Trackers        []*Tracker    `json:"trackers"`
	Webseeds        []*Webseed    `json:"webseeds"`
	Private         bool          `json:"private"`
	Error           *string       `json:"error,omitempty"`
}

type Tracker struct {
	URL          string        `json:"url"`
	Status       TrackerStatus `json:"status"`
	Leechers     *int          `json:"leechers,omitempty"`
	Seeders      *int          `json:"seeders,omitempty"`
	Error        *string       `json:"error,omitempty"`
	NextAnnounce *time.Time    `json:"nextAnnounce,omitempty"`
	LastAnnounce *time.Time    `json:"lastAnnounce,omitempty"`
}

type Webseed struct {
	URL             string  `json:"url"`
	DownloadSpeed   int     `json:"downloadSpeed"`
	BytesDownloaded string  `json:"bytesDownloaded"`
	Error           *string `json:"error,omitempty"`
}

type PeerSource string

const (
	PeerSourceTracker  PeerSource = "TRACKER"
	PeerSourceDht      PeerSource = "DHT"
	PeerSourcePex      PeerSource = "PEX"
	PeerSourceIncoming PeerSource = "INCOMING"
)

var AllPeerSource = []PeerSource{
	PeerSourceTracker,
	PeerSourceDht,
	PeerSourcePex,
	PeerSourceIncoming,
}

func (e PeerSource) IsValid() bool {
	switch e {
	case PeerSourceTracker, PeerSourceDht, PeerSourcePex, PeerSourceIncoming:
		return true
	}
	return false
}

func (e PeerSource) String() string {
	return string(e)
}

func (e *PeerSource) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PeerSource(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PeerSource", str)
	}
	return nil
}

func (e PeerSource) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PeerSource) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PeerSource) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TorrentStatus string

const (
	TorrentStatusStopped             TorrentStatus = "STOPPED"
	TorrentStatusDownloadingMetadata TorrentStatus = "DOWNLOADING_METADATA"
	TorrentStatusAllocating          TorrentStatus = "ALLOCATING"
	TorrentStatusVerifying           TorrentStatus = "VERIFYING"
	TorrentStatusDownloading         TorrentStatus = "DOWNLOADING"
	TorrentStatusSeeding             TorrentStatus = "SEEDING"
	TorrentStatusStopping            TorrentStatus = "STOPPING"
)

var AllTorrentStatus = []TorrentStatus{
	TorrentStatusStopped,
	TorrentStatusDownloadingMetadata,
	TorrentStatusAllocating,
	TorrentStatusVerifying,
	TorrentStatusDownloading,
	TorrentStatusSeeding,
	TorrentStatusStopping,
}

func (e TorrentStatus) IsValid() bool {
	switch e {
	case TorrentStatusStopped, TorrentStatusDownloadingMetadata, TorrentStatusAllocating, TorrentStatusVerifying, TorrentStatusDownloading, TorrentStatusSeeding, TorrentStatusStopping:
		return true
	}
	return false
}

func (e TorrentStatus) String() string {
	return string(e)
}

func (e *TorrentStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TorrentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TorrentStatus", str)
	}
	return nil
}

func (e TorrentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TorrentStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TorrentStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TrackerStatus string

const (
	TrackerStatusIdle       TrackerStatus = "IDLE"
	TrackerStatusAnnouncing TrackerStatus = "ANNOUNCING"
	TrackerStatusWaiting    TrackerStatus = "WAITING"
	TrackerStatusError      TrackerStatus = "ERROR"
)

var AllTrackerStatus = []TrackerStatus{
	TrackerStatusIdle,
	TrackerStatusAnnouncing,
	TrackerStatusWaiting,
	TrackerStatusError,
}

func (e TrackerStatus) IsValid() bool {
	switch e {
	case TrackerStatusIdle, TrackerStatusAnnouncing, TrackerStatusWaiting, TrackerStatusError:
		return true
	}
	return false
}

func (e TrackerStatus) String() string {
	return string(e)
}

func (e *TrackerStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TrackerStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TrackerStatus", str)
	}
	return nil
}

func (e TrackerStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TrackerStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TrackerStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
